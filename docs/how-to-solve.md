### 미션 해결 전략 
#### 1. 본인이 이해하고 구현한 내용에 기반해 '다른 근무자와 순서를 바꿔야 하는 경우'를 자신만의 예시를 들어 설명하세요. (필수)       

다른 근무자와 순서를 바꿔야 하는 경우는 다음과 같다.
- 근거: 근무자 보호와 비상 근무 운영의 효율을 위해, 비상 근무자는 어떤 경우에도 연속 2일은 근무할 수 없다
  - 2일 근무가 불가능하기 때문에, 자연스레 2일 이상 부터 연속 근무가 불가능하다
  - 최소한 격일로 돌아가며 근무해야 한다
- 상황 A: 이틀 연속 근무인 경우
  - ex) [A, A, B], [A, B, A, A] -> 불가능
- 상황 B: 이틀 이상 연속 근무인 경우
  - ex) [A, A, A, B] -> 불가능

다음은 근무가 가능한 특별한 경우이다.
- 격일로 연속 근무하는 것은 가능하다
  - [A, B, A] -> 가능

제시된 요구사항 중 `다음 근무자와 순서를 바꿔야 하는 경우에는, 앞의 날짜부터 순서를 변경`이 존재해 앞, 뒤 삽입/삭제가 편리한 자료구조 선택이 좋다
- `ArrayDeque`를 사용해 평일 근무 후 휴일 근무인 경우 다음 휴일 근무자를 poll()해 근무를 한 뒤 addLast(), 쉰 근무자는 다시 addFirst()로 다가오는 휴일에 근무를 진행

#### 2. 요구사항에서 제시한 앞의 날짜부터 순서를 변경하는 방법 외에 다른 방법이 있다면 어떤 방식이 있는지, 이 방법은 기존에 제시된 방식과 비교해 어떤 차이가 있는지 설명하세요. (선택)
- 기존 방식은 무조건 앞의 순서와 교대하기 때문에 1 ~ 12월 전체 근무표를 짜면 더 많이 근무하는 인원이 생긴다
- 최악의 경우 모든 월에 1번 씩 더 근무하는 사람이 생기기 때문에, 1년을 전체로 잡으면 12번 더 근무하게 된다
- 또한 기존 방식의 문제점은 격일 근무가 많아진다
  - 평일-휴일-휴일-휴일-평일-평일 근무인 경우 극단적인 상황에서 [A, B(원래A), A, C, D(원래C), C] -> 격일 근무자가 2명
  - 순번에 따라 근무 편성의 형평성이 떨어진다

해결법
- 이를 해결하기 위해 기존 순번을 그대로 사용하면서 근무 횟수를 추가해 교대 순서를 정할 수 있다 생각한다
- 근무자 마다 (평일 순번, 휴일 순번, 근무 횟수)를 갖는다
- 근무자 클래스가 `Comparable<근무자>`를 구현해 `compareTo()`를 사용해 Deque 대신 `PriorityQueue` 사용이 가능하다 생각한다
  - compareTo() 조건은 다음과 같다
  - 먼저 근무 횟수가 다르면 근무 횟수를 기준으로 오름차순 정렬한다
  - 근무 횟수가 같은 근무자는 순번을 기준으로 오름차순 정렬한다
- 이렇게 `PriorityQueue`를 사용하면 좀 더 골고루 근무 횟수를 나눌 수 있다 생각한다
